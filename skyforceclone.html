<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>VOID STRIKER</title>
    <style>
        :root {
            --neon-blue: #00d2ff;
            --neon-gold: #ffc400;
            --neon-red: #ff3d3d;
            --neon-purple: #bd00ff;
            --neon-green: #39ff14;
            --glass-bg: rgba(10, 15, 25, 0.9);
        }

        body {
            margin: 0; padding: 0;
            background-color: #05070a;
            color: #fff;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            overflow: hidden;
            touch-action: none;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: #0a0e14;
            overflow: hidden;
        }

        canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(1.2);
            width: 100vw;
            height: 100vh;
            object-fit: contain;
            background: #0a0e14;
            border: none;
            outline: none;
        }

        /* --- MODERN HUD --- */
        .hud-layer {
            position: absolute; inset: 0;
            pointer-events: none;
            padding: 20px;
            display: flex; flex-direction: column;
            justify-content: space-between;
            z-index: 10;
        }

        .hud-top { display: flex; justify-content: space-between; align-items: flex-start; }

        .currency-block {
            background: var(--glass-bg);
            border-left: 4px solid var(--neon-gold);
            padding: 10px 20px;
            backdrop-filter: blur(10px);
            min-width: 120px;
        }
        .currency-value { font-size: 1.5rem; font-weight: 800; color: var(--neon-gold); }

        .combo-block {
            text-align: right;
            opacity: 0; transition: transform 0.2s, opacity 0.3s;
            transform: scale(0.8);
        }
        .combo-block.active { opacity: 1; transform: scale(1); }
        .combo-count { font-size: 3rem; font-weight: 900; color: var(--neon-blue); line-height: 1; text-shadow: 0 0 20px var(--neon-blue); }

        .vitals-block {
            width: 260px;
            background: var(--glass-bg);
            padding: 15px;
            border-bottom: 4px solid var(--neon-blue);
        }

        .bar-container { margin-bottom: 10px; }
        .bar-label { display: flex; justify-content: space-between; font-size: 0.65rem; text-transform: uppercase; margin-bottom: 4px; font-weight: 700; }
        .bar-bg { width: 100%; height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; overflow: hidden; }
        .bar-fill { height: 100%; width: 100%; transition: width 0.1s; }
        
        #hp-fill { background: var(--neon-blue); box-shadow: 0 0 10px var(--neon-blue); }
        #burst-fill { background: var(--neon-gold); box-shadow: 0 0 10px var(--neon-gold); }
        #burst-fill.overheat { background: var(--neon-red); animation: pulse 0.3s infinite; }

        .powerup-slot {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 80px;
            height: 80px;
            background: var(--glass-bg);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
        }
        .powerup-slot.ready { border-color: var(--neon-gold); box-shadow: 0 0 15px var(--neon-gold); }
        .slot-icon { font-size: 2rem; }
        .slot-key { font-size: 0.6rem; font-weight: 800; color: #888; margin-top: 4px; }
        
        .active-powerup-bar {
            position: absolute;
            bottom: 110px;
            right: 20px;
            width: 80px;
            height: 4px;
            background: rgba(255,255,255,0.1);
        }
        #pwr-timer-fill { height: 100%; width: 0%; background: var(--neon-green); transition: width 0.1s linear; }

        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }

        .overlay {
            position: absolute; inset: 0;
            background: rgba(0,0,0,0.85);
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            z-index: 100;
            backdrop-filter: blur(15px);
            overflow-y: auto;
            padding: 40px 0;
        }

        .btn {
            width: 280px; padding: 18px; margin: 8px;
            background: none; border: 2px solid #fff;
            color: #fff; font-weight: 700;
            text-transform: uppercase; cursor: pointer;
            transition: 0.2s; letter-spacing: 2px;
        }
        .btn:hover { background: #fff; color: #000; transform: translateY(-2px); }
        .btn-primary { background: var(--neon-blue); border-color: var(--neon-blue); color: #000; }
        .btn-danger { border-color: var(--neon-red); color: var(--neon-red); }
        .btn-danger:hover { background: var(--neon-red); color: #fff; }

        .fleet-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 10px;
            width: 90%; max-width: 800px; margin-bottom: 20px;
        }
        .ship-card {
            background: rgba(255,255,255,0.05); padding: 15px;
            border: 1px solid rgba(255,255,255,0.1);
            cursor: pointer; position: relative;
            text-align: left;
            transition: 0.2s;
        }
        .ship-card:hover { background: rgba(255,255,255,0.1); transform: scale(1.02); }
        .ship-card.selected { border-color: var(--neon-blue); background: rgba(0, 210, 255, 0.1); }
        .ship-card.locked { opacity: 0.4; }
        .ship-price { color: var(--neon-gold); font-size: 0.8rem; font-weight: 800; }
        .ship-ability { font-size: 0.65rem; color: var(--neon-green); margin-top: 5px; font-weight: bold; }

        .hidden { display: none !important; }

        #combo-glow {
            position: absolute; inset: 0;
            pointer-events: none;
            box-shadow: inset 0 0 0px var(--neon-blue);
            transition: box-shadow 0.5s;
            z-index: 5;
        }
    </style>
</head>
<body>

<div id="game-container">
    <div id="combo-glow"></div>
    <div class="hud-layer">
        <div class="hud-top">
            <div class="currency-block">
                <div class="currency-value">ðŸª™ <span id="coin-val">0</span></div>
            </div>
            <div id="combo-ui" class="combo-block">
                <div class="combo-count">X<span id="combo-val">1</span></div>
            </div>
        </div>

        <div class="vitals-block">
            <div class="bar-container">
                <div class="bar-label"><span>Armor</span><span id="hp-text">100%</span></div>
                <div class="bar-bg"><div id="hp-fill" class="bar-fill"></div></div>
            </div>
            <div class="bar-container">
                <div class="bar-label"><span>Capacitor</span><span id="burst-text">READY</span></div>
                <div class="bar-bg"><div id="burst-fill" class="bar-fill"></div></div>
            </div>
        </div>

        <div class="active-powerup-bar"><div id="pwr-timer-fill"></div></div>
        <div id="pwr-slot" class="powerup-slot">
            <div id="slot-icon" class="slot-icon"></div>
            <div class="slot-key">SHIFT</div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="menu-overlay" class="overlay">
        <h1 style="font-size: 4rem; font-weight: 900; margin: 0;">VOID STRIKER</h1>
        <p style="color: var(--neon-blue); letter-spacing: 8px; margin-bottom: 40px;">DEEP SPACE COMBAT</p>
        <button class="btn btn-primary" onclick="startGame()">Start Game</button>
        <button class="btn" onclick="showFleet()">Select Ship</button>
        <button class="btn" onclick="showShop()">Upgrades</button>
        <div style="margin-top: 20px; font-size: 0.7rem; color: #666; letter-spacing: 1px;">WASD: MOVE | SPACE: BURST | SHIFT: POWERUP | P: PAUSE</div>
    </div>

    <div id="pause-overlay" class="overlay hidden">
        <h1 style="font-size: 3rem; margin-bottom: 30px;">PAUSED</h1>
        <button class="btn btn-primary" onclick="togglePause()">Resume Game</button>
        <button class="btn" onclick="startGame()">Restart</button>
        <button class="btn btn-danger" onclick="exitGame()">Exit Game</button>
    </div>

    <div id="fleet-overlay" class="overlay hidden">
        <h2 style="margin-top:0">SELECT SHIP</h2>
        <div id="ship-list" class="fleet-grid"></div>
        <button class="btn" onclick="hideFleet()">Back</button>
    </div>

    <div id="shop-overlay" class="overlay hidden">
        <h2 style="margin-top:0">HANGAR UPGRADES</h2>
        <p style="color: var(--neon-gold);">Credits: ðŸª™ <span id="shop-gold">0</span></p>
        <div id="upgrade-list" class="fleet-grid"></div>
        <button class="btn" onclick="hideShop()">Back</button>
    </div>

    <div id="gameover-overlay" class="overlay hidden">
        <h1 style="color: var(--neon-red);">MISSION FAILED</h1>
        <div id="stats-summary" style="margin: 20px; text-align: center;"></div>
        <button class="btn btn-primary" onclick="startGame()">Retry</button>
        <button class="btn" onclick="hideGameOver()">Menu</button>
    </div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const WIDTH = 540;
const HEIGHT = 900;
canvas.width = WIDTH;
canvas.height = HEIGHT;

let gameState = 'MENU';
let coinsEarned = 0, combo = 1, comboTimer = 0, frameCount = 0, shake = 0;
let burstEnergy = 100, isOverheated = false;
let armorFlash = 0;
let lastTime = 0, deltaTime = 0;

// Parallax background layers
let stars = [], nebulae = [], bgStarsFar = [];

const SHIPS = {
    viper: { name: "VIPER", hp: 100, speed: 8.5, dmg: 1.0, price: 0, color: '#00d2ff', accent: '#ffffff', ability: "Balanced Performance" },
    phantom: { name: "PHANTOM", hp: 80, speed: 11, dmg: 0.8, price: 1500, color: '#2c3e50', accent: '#39ff14', ability: "Stealth: -50% Dmg Taken" },
    titan: { name: "TITAN", hp: 250, speed: 5.5, dmg: 1.4, price: 3500, color: '#7f8c8d', accent: '#e67e22', ability: "Hull: Heavy Ramming Dmg" },
    spectre: { name: "SPECTRE", hp: 110, speed: 9, dmg: 1.2, price: 6000, color: '#c0392b', accent: '#000000', ability: "Siphon: Hits Repair Armor" },
    aegis: { name: "AEGIS", hp: 400, speed: 4.5, dmg: 1.0, price: 10000, color: '#f1c40f', accent: '#ffffff', ability: "Bastion: Large Shield Area" },
    zenith: { name: "ZENITH", hp: 60, speed: 13, dmg: 2.5, price: 20000, color: '#9b59b6', accent: '#00d2ff', ability: "Overload: Permanent Rapid" }
};

let saveData = {
    gold: 500,
    currentShip: 'viper',
    unlockedShips: ['viper'],
    upgrades: { 
        armor: 1, guns: 1, wingGuns: 0, engine: 1, magnet: 1, luck: 1, refinement: 1,
        shieldStrength: 0, burstCapacity: 1, comboMaster: 1, scavenger: 1, overclock: 0
    }
};

const LOCAL_SAVE_KEY = 'skyforce_v7';

async function loadSaveData() {
    const localSaved = localStorage.getItem(LOCAL_SAVE_KEY);
    try {
        const resp = await fetch('/api/save');
        if (resp.ok) {
            const json = await resp.json();
            if (json && json.saveData) {
                saveData = { ...saveData, ...json.saveData };
                localStorage.setItem(LOCAL_SAVE_KEY, JSON.stringify(saveData));
                return;
            }
        }
    } catch (err) {
        console.warn('Falling back to local save data', err);
    }
    if (localSaved) {
        try {
            const parsed = JSON.parse(localSaved);
            saveData = { ...saveData, ...parsed };
        } catch (e) {
            console.warn('Local save corrupt, using defaults');
        }
    }
}

async function persistSaveData() {
    localStorage.setItem(LOCAL_SAVE_KEY, JSON.stringify(saveData));
    try {
        await fetch('/api/save', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ saveData })
        });
    } catch (err) {
        console.warn('Unable to sync save to server, kept local only', err);
    }
}

const UPGRADES = {
    scavenger: { name: "Scavenger", cost: 100, desc: "Small chance to drop repair kits on kill", max: 500 },
    engine: { name: "Engines", cost: 150, desc: "Faster movement and banking", max: 800 },
    armor: { name: "Reinforced Armor", cost: 200, desc: "Higher total HP pools", max: 900 },
    guns: { name: "Main Cannon", cost: 250, desc: "Firing rate & damage", max: 900 },
    magnet: { name: "Item Magnet", cost: 300, desc: "Pulls items from further away", max: 500 },
    burstCapacity: { name: "Capacitor", cost: 350, desc: "Longer burst fire duration", max: 600 },
    refinement: { name: "Coin Refiner", cost: 400, desc: "Coins are worth more credits", max: 700 },
    luck: { name: "Luck Chip", cost: 500, desc: "Increase powerup drop rates", max: 400 },
    shieldStrength: { name: "Energy Shield", cost: 600, desc: "Reduce damage taken globally", max: 500 },
    comboMaster: { name: "Combo Master", cost: 750, desc: "Combo timer lasts longer", max: 400 },
    wingGuns: { name: "Wing Pods", cost: 1200, desc: "Additional side-mounted projectiles", max: 10 },
    overclock: { name: "Overclock", cost: 2500, desc: "Massive damage at cost of heat", max: 100 }
};

const keys = {};
window.addEventListener('keydown', e => {
    keys[e.code] = true;
    if (e.code === 'KeyP' || e.code === 'Escape') {
        if (gameState === 'PLAYING' || gameState === 'PAUSED') togglePause();
    }
    if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
        if (gameState === 'PLAYING') player.activatePowerup();
    }
});
window.addEventListener('keyup', e => keys[e.code] = false);

const POWERUP_TYPES = {
    SHIELD: { color: '#39ff14', icon: 'ðŸ›¡ï¸', label: 'SHIELD' },
    RAPID: { color: '#ff3d3d', icon: 'ðŸ”¥', label: 'RAPID FIRE' },
    HEALTH: { color: '#bd00ff', icon: 'âž•', label: 'REPAIR' },
    TRIPLE: { color: '#00d2ff', icon: 'ðŸ”±', label: 'TRIPLE SHOT' }
};

class Player {
    constructor() { this.reset(); }
    reset() {
        const stats = SHIPS[saveData.currentShip];
        this.x = WIDTH / 2;
        this.y = HEIGHT - 150;
        this.maxHp = stats.hp + (saveData.upgrades.armor * 30);
        this.hp = this.maxHp;
        this.fireTimer = 0;
        this.bank = 0;
        this.targetBank = 0;
        this.storedPowerup = null;
        this.activePowerup = null;
        this.powerupTimer = 0;
        this.powerupDuration = 600;
        this.siphonCounter = 0;
        this.moveSpeed = 400; // pixels per second
        this.rotationSpeed = 3; // rotation speed multiplier
        // Ship visual bounds to prevent clipping
        this.visualWidth = (saveData.currentShip === 'titan' || saveData.currentShip === 'aegis') ? 50 : 45;
    }
    collectPowerup(type) {
        if (type === 'HEALTH') {
            this.hp = Math.min(this.maxHp, this.hp + (this.maxHp * 0.4));
            return;
        }
        this.storedPowerup = type;
        document.getElementById('slot-icon').innerText = POWERUP_TYPES[type].icon;
        document.getElementById('pwr-slot').classList.add('ready');
    }
    activatePowerup() {
        if (!this.storedPowerup) return;
        this.activePowerup = this.storedPowerup;
        this.storedPowerup = null;
        this.powerupTimer = this.powerupDuration;
        document.getElementById('slot-icon').innerText = '';
        document.getElementById('pwr-slot').classList.remove('ready');
    }
    takeDamage(amt) {
        const ship = saveData.currentShip;
        let reduction = (saveData.upgrades.shieldStrength * 0.02);
        let actualDmg = amt * (1 - Math.min(0.8, reduction));
        if (ship === 'phantom') actualDmg *= 0.5;
        this.hp -= actualDmg;
        armorFlash = 1.0; 
        shake = 15;
    }
    update() {
        const stats = SHIPS[saveData.currentShip];
        const speed = (stats.speed + (saveData.upgrades.engine * 0.5)) * 30; // Base speed multiplier
        const moveAmount = speed * deltaTime;
        
        let moveX = 0;
        if (keys['ArrowLeft'] || keys['KeyA']) moveX -= 1;
        if (keys['ArrowRight'] || keys['KeyD']) moveX += 1;
        this.x += moveX * moveAmount;
        
        if (keys['ArrowUp'] || keys['KeyW']) this.y -= moveAmount;
        if (keys['ArrowDown'] || keys['KeyS']) this.y += moveAmount;
        
        this.targetBank = moveX * 0.35; 
        const bankSmoothness = 0.12; 
        this.bank += (this.targetBank - this.bank) * bankSmoothness;

        // FIXED CLIPPING: Account for visual width + rotation offset
        const edgeMargin = this.visualWidth + (Math.abs(this.bank) * 20);
        this.x = Math.max(edgeMargin, Math.min(WIDTH - edgeMargin, this.x));
        this.y = Math.max(80, Math.min(HEIGHT - 80, this.y));
        
        const isZenith = saveData.currentShip === 'zenith';
        const attemptingBurst = keys['Space'] && !isOverheated;
        
        // Convert fire rate to shots per second and use delta time
        let shotsPerSecond = 10 + (saveData.upgrades.guns * 1.5); // Base 10 shots/sec + upgrades
        if (isZenith || this.activePowerup === 'RAPID') shotsPerSecond = 30; // Faster firing in rapid fire mode
        
        const shotCooldown = 1 / shotsPerSecond; // Time between shots in seconds
        
        if (attemptingBurst && burstEnergy > 0) {
            // Triple fire rate when bursting
            this.fireTimer += deltaTime * 3;
            let cost = 10 * deltaTime / (1 + saveData.upgrades.burstCapacity * 0.1);
            burstEnergy = Math.max(0, burstEnergy - cost);
            if (burstEnergy <= 0) isOverheated = true;
        } else {
            this.fireTimer += deltaTime;
            burstEnergy = Math.min(100, burstEnergy + 15 * deltaTime);
            if (isOverheated && burstEnergy >= 40) isOverheated = false;
        }

        // Shoot if enough time has passed
        while (this.fireTimer >= shotCooldown) {
            this.shoot(attemptingBurst);
            this.fireTimer -= shotCooldown;
        }

        if (this.activePowerup) {
            this.powerupTimer--;
            document.getElementById('pwr-timer-fill').style.width = (this.powerupTimer / this.powerupDuration * 100) + '%';
            if (this.powerupTimer <= 0) {
                this.activePowerup = null;
            }
        } else {
            document.getElementById('pwr-timer-fill').style.width = '0%';
        }

        document.getElementById('hp-fill').style.width = (this.hp / this.maxHp * 100) + '%';
        document.getElementById('hp-text').innerText = Math.floor(this.hp / this.maxHp * 100) + '%';
        document.getElementById('burst-fill').style.width = burstEnergy + '%';
        document.getElementById('burst-fill').className = isOverheated ? 'bar-fill overheat' : 'bar-fill';
        document.getElementById('burst-text').innerText = isOverheated ? 'OVERHEAT' : (attemptingBurst ? 'BURSTING' : 'READY');
    }
    shoot(isBurst) {
        const gunsLevel = saveData.upgrades.guns;
        const dmg = SHIPS[saveData.currentShip].dmg * (1 + (gunsLevel * 0.1) + (saveData.upgrades.overclock * 0.5));
        const isTriple = this.activePowerup === 'TRIPLE';
        
        let bulletColor = '#00d2ff';
        let isHoming = false;
        if (gunsLevel >= 8) {
            bulletColor = '#bd00ff';
            isHoming = true;
        } else if (gunsLevel >= 4) {
            bulletColor = '#00d2ff';
        } else {
            bulletColor = '#ffffff';
        }

        bullets.push(new Bullet(this.x - 8, this.y - 25, isBurst, dmg, 0, bulletColor, isHoming));
        bullets.push(new Bullet(this.x + 8, this.y - 25, isBurst, dmg, 0, bulletColor, isHoming));
        if (isTriple) {
            bullets.push(new Bullet(this.x - 20, this.y - 15, isBurst, dmg, -0.2, bulletColor, isHoming));
            bullets.push(new Bullet(this.x + 20, this.y - 15, isBurst, dmg, 0.2, bulletColor, isHoming));
        }
        if (saveData.upgrades.wingGuns > 0) {
            bullets.push(new Bullet(this.x - 28, this.y - 10, isBurst, dmg * 0.5, 0, bulletColor, isHoming));
            bullets.push(new Bullet(this.x + 28, this.y - 10, isBurst, dmg * 0.5, 0, bulletColor, isHoming));
        }
    }
    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.bank);
        const stats = SHIPS[saveData.currentShip];
        const color = stats.color;
        const accent = stats.accent;

        const engineSize = 10 + Math.random() * 8 + (saveData.upgrades.engine * 0.2);
        ctx.fillStyle = isOverheated ? '#ff3d3d' : (keys['Space'] ? '#ffc400' : '#00d2ff');
        ctx.shadowBlur = 15; ctx.shadowColor = ctx.fillStyle;
        ctx.beginPath(); ctx.arc(-12, 25, engineSize, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(12, 25, engineSize, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;

        ctx.fillStyle = color;
        if (saveData.currentShip === 'titan' || saveData.currentShip === 'aegis') {
            ctx.beginPath(); ctx.moveTo(-15, 0); ctx.lineTo(-45, 10); ctx.lineTo(-45, 35); ctx.lineTo(-15, 20); ctx.closePath(); ctx.fill();
            ctx.beginPath(); ctx.moveTo(15, 0); ctx.lineTo(45, 10); ctx.lineTo(45, 35); ctx.lineTo(15, 20); ctx.closePath(); ctx.fill();
            ctx.fillStyle = accent; ctx.fillRect(-40, 15, 5, 15); ctx.fillRect(35, 15, 5, 15);
        } else {
            ctx.beginPath(); ctx.moveTo(-15, -10); ctx.lineTo(-40, 15); ctx.lineTo(-15, 20); ctx.closePath(); ctx.fill();
            ctx.beginPath(); ctx.moveTo(15, -10); ctx.lineTo(40, 15); ctx.lineTo(15, 20); ctx.closePath(); ctx.fill();
            ctx.strokeStyle = accent; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.moveTo(-20, 0); ctx.lineTo(-35, 10); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(20, 0); ctx.lineTo(35, 10); ctx.stroke();
        }

        ctx.fillStyle = color;
        ctx.beginPath(); ctx.moveTo(0, -50); ctx.lineTo(18, 0); ctx.lineTo(22, 35); ctx.lineTo(-22, 35); ctx.lineTo(-18, 0); ctx.closePath(); ctx.fill();
        ctx.fillStyle = accent; ctx.globalAlpha = 0.5; ctx.fillRect(-3, -30, 6, 60); ctx.globalAlpha = 1;
        const grd = ctx.createLinearGradient(0, -25, 0, -5); grd.addColorStop(0, '#1a1a1a'); grd.addColorStop(1, '#4facfe');
        ctx.fillStyle = grd; ctx.beginPath(); ctx.ellipse(0, -18, 9, 16, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = 'rgba(255,255,255,0.4)'; ctx.beginPath(); ctx.ellipse(-3, -22, 3, 6, 0.2, 0, Math.PI*2); ctx.fill();

        const shieldRadius = saveData.currentShip === 'aegis' ? 75 : 55;
        if (armorFlash > 0 || this.activePowerup === 'SHIELD') {
            ctx.strokeStyle = this.activePowerup === 'SHIELD' ? 'rgba(57, 255, 20, 0.8)' : `rgba(0, 210, 255, ${armorFlash})`;
            ctx.lineWidth = 4; ctx.beginPath(); ctx.arc(0, 0, shieldRadius, 0, Math.PI*2); ctx.stroke();
            if (armorFlash > 0) armorFlash -= 0.05;
        }
        ctx.restore();
    }
}

class Bullet {
    constructor(x, y, isBurst, dmg, angleOffset = 0, color = '#00d2ff', homing = false) {
        this.x = x; this.y = y; this.isBurst = isBurst; this.dmg = dmg;
        this.speed = 400; // pixels per second
        this.angleOffset = angleOffset * 0.5; // Reduce angle offset for better control
        this.baseVx = this.angleOffset * this.speed * 0.1;
        this.baseVy = -this.speed * 0.1;
        this.vx = this.baseVx;
        this.vy = this.baseVy;
        this.color = color;
        this.homing = homing;
        this.radius = 6;
        this.active = true;
    }
    update() {
        const baseSpeed = this.speed * deltaTime;
        
        if (this.homing) {
            let target = null;
            let minDistSq = 200000;
            enemies.forEach(e => {
                let dSq = (e.x - this.x)**2 + (e.y - this.y)**2;
                if (dSq < minDistSq) {
                    minDistSq = dSq;
                    target = e;
                }
            });
            
            if (target) {
                let angle = Math.atan2(target.y - this.y, target.x - this.x);
                // Smooth homing with delta time
                const turnRate = 2.5 * deltaTime;
                const targetVx = Math.cos(angle) * baseSpeed;
                const targetVy = Math.sin(angle) * baseSpeed;
                this.vx += (targetVx - this.vx) * turnRate;
                this.vy += (targetVy - this.vy) * turnRate;
                
                // Normalize speed
                const mag = Math.sqrt(this.vx**2 + this.vy**2);
                if (mag > 0) {
                    this.vx = (this.vx / mag) * baseSpeed * 1.2;
                    this.vy = (this.vy / mag) * baseSpeed * 1.2;
                }
            } else {
                // Maintain base velocity when no target
                this.vx = this.baseVx * deltaTime * 60;
                this.vy = this.baseVy * deltaTime * 60;
            }
        } else {
            // Non-homing bullets use constant velocity with delta time
            this.vx = this.baseVx * deltaTime * 60;
            this.vy = this.baseVy * deltaTime * 60;
        }
        
        this.x += this.vx;
        this.y += this.vy; 
    }
    draw() {
        ctx.fillStyle = this.isBurst ? '#ffc400' : this.color;
        ctx.fillRect(this.x - 3, this.y - 15, 6, 30);
    }
}

class Coin {
    constructor(x, y, value) {
        this.x = x; this.y = y; this.value = value;
        this.vx = (Math.random() - 0.5) * 6;
        this.vy = -Math.random() * 5;
        this.gravity = 0.15;
        this.angle = 0;
        this.radius = 12;
        this.active = true;
    }
    update() {
        const magnetRange = 100 + (saveData.upgrades.magnet * 45);
        const dx = this.x - player.x;
        const dy = this.y - player.y;
        const distSq = dx*dx + dy*dy;
        
        if (distSq < magnetRange * magnetRange) {
            const angle = Math.atan2(-dy, -dx);
            const pullStrength = 8 + (saveData.upgrades.magnet * 0.5);
            this.x += Math.cos(angle) * pullStrength;
            this.y += Math.sin(angle) * pullStrength;
        } else {
            this.vy += this.gravity;
            this.x += this.vx;
            this.y += this.vy;
            this.vx *= 0.98;
        }
        this.angle += 0.2;
    }
    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.scale(Math.cos(this.angle), 1);
        ctx.fillStyle = '#ffc400';
        ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
        ctx.fillStyle = '#f39c12'; ctx.font = 'bold 10px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText('$', 0, 0);
        ctx.restore();
    }
}

class Powerup {
    constructor(x, y, type) { this.x = x; this.y = y; this.type = type; this.speed = 2.5; this.size = 20; this.active = true; }
    update() {
        const magnetRange = 100 + (saveData.upgrades.magnet * 40);
        const dx = this.x - player.x;
        const dy = this.y - player.y;
        const distSq = dx*dx + dy*dy;
        if (distSq < magnetRange * magnetRange) {
            const angle = Math.atan2(-dy, -dx);
            this.x += Math.cos(angle) * 8; this.y += Math.sin(angle) * 8;
        } else { this.y += this.speed; }
    }
    draw() {
        ctx.save(); ctx.translate(this.x, this.y); ctx.shadowBlur = 10; ctx.shadowColor = POWERUP_TYPES[this.type].color;
        ctx.fillStyle = POWERUP_TYPES[this.type].color; ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#fff'; ctx.font = '16px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(POWERUP_TYPES[this.type].icon, 0, 0);
        ctx.restore();
    }
}

class Enemy {
    constructor(x, y, type = 'INTERCEPTOR') {
        this.x = x; this.y = y; this.type = type; this.isBoss = type === 'BOSS';
        this.hp = this.isBoss ? 300 : (type === 'HEAVY' ? 45 : 12);
        this.maxHp = this.hp; this.speed = this.isBoss ? 0.6 : (type === 'HEAVY' ? 1.5 : 3.5);
        this.hitFlash = 0; this.angle = 0; this.active = true;
        this.radius = this.isBoss ? 100 : (type === 'HEAVY' ? 40 : 25);
        this.pattern = Math.random() < 0.3 ? 'WAVE' : (Math.random() < 0.3 ? 'DIAGONAL' : 'STRAIGHT');
        this.seed = Math.random() * 1000;
        this.startX = x;
        this.fireTimer = Math.floor(Math.random() * (this.isBoss ? 15 : (this.type === 'HEAVY' ? 45 : 70)));
    }
    update() {
        if (this.pattern === 'WAVE') {
            this.y += this.speed;
            this.x = this.startX + Math.sin(this.y / 60 + this.seed) * 80;
        } else if (this.pattern === 'DIAGONAL') {
            this.y += this.speed;
            this.x += Math.sin(this.seed) * 2;
        } else {
            this.y += this.speed;
        }

        if (this.isBoss && this.y > 150) {
            this.y = 150;
            this.x = (WIDTH/2) + Math.sin(frameCount * 0.02) * 150;
        }
        
        if (this.hitFlash > 0) this.hitFlash--;
        this.angle += 0.02;
        let fireRate = this.isBoss ? 15 : (this.type === 'HEAVY' ? 45 : 70);
        this.fireTimer++;
        if (this.fireTimer >= fireRate) {
            this.fireTimer = 0;
            enemyBullets.push(new EnemyBullet(this.x, this.y));
            if (this.isBoss) {
                enemyBullets.push(new EnemyBullet(this.x - 60, this.y + 40));
                enemyBullets.push(new EnemyBullet(this.x + 60, this.y + 40));
            }
        }
        if (this.y > HEIGHT + 200) this.active = false;
    }
    draw() {
        ctx.save(); ctx.translate(this.x, this.y);
        if (this.hitFlash > 0) ctx.filter = 'brightness(500%)';
        if (this.isBoss) this.drawBoss();
        else if (this.type === 'HEAVY') this.drawHeavy();
        else this.drawInterceptor();
        ctx.filter = 'none';
        ctx.restore();
    }
    drawInterceptor() {
        ctx.fillStyle = '#444'; ctx.beginPath(); ctx.moveTo(-30, 0); ctx.lineTo(30, 0); ctx.lineTo(0, 20); ctx.closePath(); ctx.fill();
        ctx.fillStyle = '#c0392b'; ctx.beginPath(); ctx.moveTo(0, 30); ctx.lineTo(12, 0); ctx.lineTo(0, -10); ctx.lineTo(-12, 0); ctx.closePath(); ctx.fill();
        ctx.fillStyle = '#111'; ctx.beginPath(); ctx.ellipse(0, 5, 4, 8, 0, 0, Math.PI*2); ctx.fill();
    }
    drawHeavy() {
        ctx.fillStyle = '#2c3e50'; ctx.fillRect(-35, -20, 15, 40); ctx.fillRect(20, -20, 15, 40);
        ctx.fillStyle = '#7f8c8d'; ctx.beginPath(); ctx.moveTo(-25, -25); ctx.lineTo(25, -25); ctx.lineTo(30, 25); ctx.lineTo(-30, 25); ctx.closePath(); ctx.fill();
        ctx.fillStyle = '#e67e22'; ctx.fillRect(-15, -10, 30, 5);
        ctx.save(); ctx.rotate(this.angle); ctx.fillStyle = '#34495e'; ctx.fillRect(-5, -5, 10, 25); ctx.restore();
    }
    drawBoss() {
        ctx.shadowBlur = 30; ctx.shadowColor = 'rgba(231, 76, 60, 0.5)';
        ctx.fillStyle = '#222'; ctx.fillRect(-50, -60, 100, 30);
        ctx.fillStyle = '#333'; ctx.beginPath(); ctx.moveTo(-120, -30); ctx.lineTo(120, -30); ctx.lineTo(140, 60); ctx.lineTo(80, 100); ctx.lineTo(-80, 100); ctx.lineTo(-140, 60); ctx.closePath(); ctx.fill();
        ctx.fillStyle = '#444'; ctx.fillRect(-100, 0, 200, 20); ctx.fillRect(-70, 40, 140, 30);
        const pulse = Math.sin(frameCount * 0.1) * 5;
        ctx.fillStyle = '#e74c3c'; ctx.beginPath(); ctx.arc(-60, 60, 10 + pulse, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(60, 60, 10 + pulse, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#555'; ctx.fillRect(-100, -85, 200, 8);
        ctx.fillStyle = '#e74c3c'; ctx.fillRect(-100, -85, (this.hp/this.maxHp)*200, 8);
    }
}

class EnemyBullet {
    constructor(x, y) {
        this.x = x; this.y = y;
        const angle = Math.atan2(player.y - y, player.x - x);
        this.vx = Math.cos(angle) * 5.5; this.vy = Math.sin(angle) * 5.5;
        this.active = true;
    }
    update() { 
        this.x += this.vx; this.y += this.vy; 
        if (this.y > HEIGHT + 50 || this.y < -50 || this.x < -50 || this.x > WIDTH + 50) this.active = false;
    }
    draw() {
        ctx.fillStyle = '#ff3d3d'; ctx.beginPath(); ctx.arc(this.x, this.y, 6, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 0.3; ctx.beginPath(); ctx.arc(this.x, this.y, 12, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1;
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x; this.y = y; this.vx = (Math.random() - 0.5) * 12; this.vy = (Math.random() - 0.5) * 12;
        this.life = 1.0; this.color = color; this.size = Math.random() * 5 + 2;
    }
    update() { this.x += this.vx; this.y += this.vy; this.life -= 0.025; this.size *= 0.98; }
    draw() {
        ctx.globalAlpha = this.life; ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1;
    }
}

let player, bullets = [], enemies = [], enemyBullets = [], particles = [], powerups = [], drops = [];

function update() {
    if (gameState !== 'PLAYING') return;
    frameCount++;
    if (comboTimer > 0) {
        comboTimer--;
        if (comboTimer <= 0) {
            combo = 1;
            document.getElementById('combo-ui').classList.remove('active');
            document.getElementById('combo-glow').style.boxShadow = 'inset 0 0 0px var(--neon-blue)';
        }
    }
    if (frameCount % 60 === 0) {
        let type = 'INTERCEPTOR';
        if (frameCount % 1200 === 0) type = 'BOSS';
        else if (frameCount % 300 === 0 && frameCount % 1200 !== 0) type = 'HEAVY';
        enemies.push(new Enemy(Math.random() * (WIDTH-160) + 80, -100, type));
    }
    
    const luckBonus = (saveData.upgrades.luck - 1) * 0.0001;
    if (Math.random() < (0.0003 + luckBonus)) {
        const types = Object.keys(POWERUP_TYPES);
        powerups.push(new Powerup(Math.random() * (WIDTH-60) + 30, -50, types[Math.floor(Math.random() * types.length)]));
    }

    player.update();
    
    bullets.forEach((b) => {
        b.update();
        if (b.y < -50) b.active = false;
        enemies.forEach((e) => {
            if (!e.active || !b.active) return;
            const dx = b.x - e.x;
            const dy = b.y - e.y;
            const distSq = dx*dx + dy*dy;
            const hitDist = e.radius + b.radius;
            if (distSq < hitDist * hitDist) {
                e.hp -= b.dmg; e.hitFlash = 3; b.active = false;
                if (saveData.currentShip === 'spectre') {
                    player.siphonCounter++;
                    if (player.siphonCounter >= 10) { player.hp = Math.min(player.maxHp, player.hp + 2); player.siphonCounter = 0; }
                }
                if (e.hp <= 0) destroyEnemy(e);
            }
        });
    });

    enemyBullets.forEach((b) => {
        b.update();
        const dx = b.x - player.x;
        const dy = b.y - player.y;
        const distSq = dx*dx + dy*dy;
        const radius = saveData.currentShip === 'aegis' ? 40 : 25;
        if (distSq < radius * radius) {
            if (player.activePowerup !== 'SHIELD') player.takeDamage(15);
            b.active = false;
            if (player.hp <= 0) endGame();
        }
    });

    enemies.forEach((e) => {
        if (!e.active) return;
        const dx = e.x - player.x;
        const dy = e.y - player.y;
        const distSq = dx*dx + dy*dy;
        if (distSq < 3600) { 
            if (saveData.currentShip === 'titan') { e.hp -= 50; player.takeDamage(10); }
            else { player.takeDamage(30); e.hp = 0; }
            if (e.hp <= 0) destroyEnemy(e);
        }
        e.update();
    });

    powerups.forEach((p) => {
        p.update();
        const dx = p.x - player.x;
        const dy = p.y - player.y;
        const distSq = dx*dx + dy*dy;
        if (distSq < 1600) { 
            player.collectPowerup(p.type); p.active = false; 
        }
    });

    drops.forEach((d) => {
        d.update();
        const dx = d.x - player.x;
        const dy = d.y - player.y;
        const distSq = dx*dx + dy*dy;
        if (distSq < 900) { 
            coinsEarned += d.value;
            document.getElementById('coin-val').innerText = coinsEarned.toLocaleString();
            d.active = false;
        }
        if (d.y > HEIGHT + 100) d.active = false;
    });

    particles.forEach((p) => {
        p.update();
    });

    bullets = bullets.filter(b => b.active);
    enemyBullets = enemyBullets.filter(b => b.active);
    enemies = enemies.filter(e => e.active);
    powerups = powerups.filter(p => p.active);
    drops = drops.filter(d => d.active);
    particles = particles.filter(p => p.life > 0);
}

function destroyEnemy(e) {
    e.active = false;
    const currentCombo = combo;
    combo++; 
    comboTimer = 180 + (saveData.upgrades.comboMaster * 10);
    
    if (Math.random() < (saveData.upgrades.scavenger * 0.001)) powerups.push(new Powerup(e.x, e.y, 'HEALTH'));
    
    const baseVal = (e.isBoss ? 500 : (e.type === 'HEAVY' ? 50 : 10));
    const refinementBonus = (1 + (saveData.upgrades.refinement * 0.15));
    const comboMultiplier = 1 + (currentCombo * 0.2); 
    const totalCoinValue = Math.floor(baseVal * refinementBonus * comboMultiplier);
    
    let numCoins = e.isBoss ? 20 : (e.type === 'HEAVY' ? 5 : 1);
    let valPerCoin = Math.ceil(totalCoinValue / numCoins);
    for(let i=0; i<numCoins; i++) {
        drops.push(new Coin(e.x + (Math.random()-0.5)*20, e.y + (Math.random()-0.5)*20, valPerCoin));
    }
    
    document.getElementById('combo-val').innerText = combo;
    document.getElementById('combo-ui').classList.add('active');
    
    const glowSize = Math.min(combo * 5, 120);
    document.getElementById('combo-glow').style.boxShadow = `inset 0 0 ${glowSize}px var(--neon-blue)`;
    
    let pCount = e.isBoss ? 40 : 10;
    if (particles.length < 400) {
        for (let i = 0; i < pCount; i++) particles.push(new Particle(e.x, e.y, e.isBoss ? '#e74c3c' : '#f39c12'));
    }
    shake = e.isBoss ? 45 : (e.type === 'HEAVY' ? 15 : 8);
}

function initBackground() {
    stars = []; nebulae = []; bgStarsFar = [];
    for (let i = 0; i < 50; i++) {
        stars.push({ x: Math.random() * WIDTH, y: Math.random() * HEIGHT, s: Math.random() * 2 + 1 });
        bgStarsFar.push({ x: Math.random() * WIDTH, y: Math.random() * HEIGHT, s: Math.random() * 0.5 + 0.5 });
    }
    for (let i = 0; i < 3; i++) {
        nebulae.push({ x: Math.random() * WIDTH, y: Math.random() * HEIGHT, r: 100 + Math.random() * 150 });
    }
}

function draw() {
    ctx.clearRect(0, 0, WIDTH, HEIGHT);
    
    ctx.fillStyle = 'rgba(255,255,255,0.1)';
    bgStarsFar.forEach(s => {
        s.y = (s.y + 0.5) % HEIGHT;
        ctx.fillRect(s.x, s.y, s.s, s.s);
    });

    ctx.globalAlpha = 0.05;
    nebulae.forEach(n => {
        n.y = (n.y + 0.8) % (HEIGHT + 400);
        let grd = ctx.createRadialGradient(n.x, n.y - 200, 0, n.x, n.y - 200, n.r);
        grd.addColorStop(0, '#bd00ff');
        grd.addColorStop(1, 'transparent');
        ctx.fillStyle = grd;
        ctx.beginPath(); ctx.arc(n.x, n.y - 200, n.r, 0, Math.PI*2); ctx.fill();
    });
    ctx.globalAlpha = 1;

    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    stars.forEach(s => {
        s.y = (s.y + 2.5) % HEIGHT;
        ctx.fillRect(s.x, s.y, s.s, s.s);
    });

    ctx.save();
    
    if (shake > 0 && gameState === 'PLAYING') {
        let sx = (Math.random()-0.5)*shake;
        let sy = (Math.random()-0.5)*shake;
        ctx.translate(sx, sy);
        shake *= 0.92;
    }
    
    enemies.forEach(e => e.draw());
    bullets.forEach(b => b.draw());
    enemyBullets.forEach(b => b.draw());
    powerups.forEach(p => p.draw());
    drops.forEach(d => d.draw());
    particles.forEach(p => p.draw());
    player.draw();
    ctx.restore();
}

function startGame() {
    gameState = 'PLAYING';
    coinsEarned = 0; combo = 1; frameCount = 0;
    burstEnergy = 100; isOverheated = false; armorFlash = 0; comboTimer = 0; shake = 0;
    enemies = []; bullets = []; enemyBullets = []; particles = []; powerups = []; drops = [];
    player.reset();
    initBackground();
    document.querySelectorAll('.overlay').forEach(o => o.classList.add('hidden'));
    document.getElementById('coin-val').innerText = "0";
    document.getElementById('pwr-slot').classList.remove('ready');
    document.getElementById('combo-ui').classList.remove('active');
    document.getElementById('combo-glow').style.boxShadow = 'none';
}

function togglePause() {
    if (gameState === 'PLAYING') {
        gameState = 'PAUSED';
        document.getElementById('pause-overlay').classList.remove('hidden');
    } else if (gameState === 'PAUSED') {
        gameState = 'PLAYING';
        document.getElementById('pause-overlay').classList.add('hidden');
    }
}

function exitGame() {
    gameState = 'MENU';
    document.querySelectorAll('.overlay').forEach(o => o.classList.add('hidden'));
    document.getElementById('menu-overlay').classList.remove('hidden');
}

function showFleet() {
    document.getElementById('menu-overlay').classList.add('hidden');
    document.getElementById('fleet-overlay').classList.remove('hidden');
    const list = document.getElementById('ship-list');
    list.innerHTML = '';
    for (let id in SHIPS) {
        const s = SHIPS[id];
        const unlocked = saveData.unlockedShips.includes(id);
        const card = document.createElement('div');
        card.className = `ship-card ${unlocked ? '' : 'locked'} ${saveData.currentShip === id ? 'selected' : ''}`;
        card.innerHTML = `<strong>${s.name}</strong><br><small>HP: ${s.hp} SPD: ${s.speed}</small><div class="ship-ability">${s.ability}</div>${unlocked ? '' : `<span class="ship-price">ðŸª™ ${s.price}</span>`}`;
        card.onclick = () => {
            if (unlocked) { saveData.currentShip = id; showFleet(); }
            else if (saveData.gold >= s.price) { saveData.gold -= s.price; saveData.unlockedShips.push(id); saveData.currentShip = id; saveFleet(); showFleet(); }
        };
        list.appendChild(card);
    }
}

function showShop() {
    document.getElementById('menu-overlay').classList.add('hidden');
    document.getElementById('shop-overlay').classList.remove('hidden');
    document.getElementById('shop-gold').innerText = saveData.gold.toLocaleString();
    const list = document.getElementById('upgrade-list');
    list.innerHTML = '';
    const sortedKeys = Object.keys(UPGRADES).sort((a, b) => {
        const costA = Math.floor(UPGRADES[a].cost * Math.pow(1.15, saveData.upgrades[a] || 0));
        const costB = Math.floor(UPGRADES[b].cost * Math.pow(1.15, saveData.upgrades[b] || 0));
        return costA - costB;
    });
    for (let key of sortedKeys) {
        const u = UPGRADES[key];
        const lvl = saveData.upgrades[key] || 0;
        const cost = Math.floor(u.cost * Math.pow(1.15, lvl));
        const card = document.createElement('div');
        card.className = 'ship-card';
        card.innerHTML = `<strong>${u.name}</strong><br><small>${u.desc}</small><br>Level: ${lvl} / ${u.max}<br><span class="ship-price">ðŸª™ ${lvl >= u.max ? 'MAX' : cost.toLocaleString()}</span>`;
        if (lvl < u.max) {
            card.onclick = () => { if (saveData.gold >= cost) { saveData.gold -= cost; saveData.upgrades[key] = (lvl + 1); saveFleet(); showShop(); } };
        } else { card.style.opacity = '0.6'; card.style.cursor = 'default'; }
        list.appendChild(card);
    }
}

function saveFleet() { persistSaveData(); }

function hideFleet() { document.getElementById('fleet-overlay').classList.add('hidden'); document.getElementById('menu-overlay').classList.remove('hidden'); }
function hideShop() { document.getElementById('shop-overlay').classList.add('hidden'); document.getElementById('menu-overlay').classList.remove('hidden'); }
function hideGameOver() { document.getElementById('gameover-overlay').classList.add('hidden'); document.getElementById('menu-overlay').classList.remove('hidden'); }

function endGame() {
    gameState = 'GAMEOVER';
    saveData.gold += coinsEarned;
    saveFleet();
    document.getElementById('gameover-overlay').classList.remove('hidden');
    document.getElementById('stats-summary').innerHTML = `Collected: ðŸª™ ${coinsEarned.toLocaleString()}<br>Bank Total: ðŸª™ ${saveData.gold.toLocaleString()}`;
}

function loop(timestamp) {
    if (!lastTime) lastTime = timestamp;
    deltaTime = (timestamp - lastTime) / 1000; // Convert to seconds
    deltaTime = Math.min(deltaTime, 0.1); // Cap delta time to prevent large jumps
    lastTime = timestamp;
    
    update();
    draw();
    requestAnimationFrame(loop);
}

async function boot() {
    await loadSaveData();
    player = new Player();
    initBackground();
    loop();
}

boot();
</script>
</body>
</html>
